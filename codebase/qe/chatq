for (unsigned i = 0; i < (unsigned)attrs.size(); i++) {
    if (attrs[i].name == lhsAttr) {
        if ((lhsFieldIsNull = rbfm->fieldIsNull(nullIndicator, i))) {
            return -2; // fix
        }
        if (!(rhsAndLhsTypesMatch = (attrs[i].type == rhsValue.type))) {
            return -3; // fix so there's no magic numbers
        }
        // If the field is null, don't print it
        bool isNull = fieldIsNull(nullIndicator, i);
        if (attrs[i].name == lhsAttr)

        lhsFieldIsNull = rbfm->fieldIsNull(nullIndicator, i);
        rhsAndLhsTypesMatch = (attrs[i].type == rhsValue.type);

        switch (attrs[i].type)
        {
            case TypeInt:
                uint32_t data_integer;
                memcpy(&data_integer, ((char*) data + offset), INT_SIZE);
                offset += INT_SIZE;

                
            break;
            case TypeReal:
                float data_real;
                memcpy(&data_real, ((char*) data + offset), REAL_SIZE);
                offset += REAL_SIZE;

                
            break;
            case TypeVarChar:
                // First VARCHAR_LENGTH_SIZE bytes describe the varchar length
                uint32_t varcharSize;
                memcpy(&varcharSize, ((char*) data + offset), VARCHAR_LENGTH_SIZE);
                // offset += VARCHAR_LENGTH_SIZE;

                // Gets the actual string.
                char *data_string = (char*) malloc(varcharSize + 1);
                if (data_string == NULL)
                    return RBFM_MALLOC_FAILED;

                memcpy(data_string, ((char*) data + offset), varcharSize);

                // Adds the string terminator.
                data_string[varcharSize] = '\0';
                offset += varcharSize;              
                
                free(data_string);
            break;
        }
    }
}